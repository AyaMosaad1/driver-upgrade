{"ast":null,"code":"import _asyncToGenerator from \"@babel/runtime/helpers/asyncToGenerator\";\nimport { EventEmitter, UnavailabilityError } from 'expo-modules-core';\nimport ExpoTaskManager from \"./ExpoTaskManager\";\nvar tasks = new Map();\nfunction _validateTaskName(taskName) {\n  if (!taskName || typeof taskName !== 'string') {\n    throw new TypeError('`taskName` must be a non-empty string.');\n  }\n}\nexport function defineTask(taskName, taskExecutor) {\n  if (!taskName || typeof taskName !== 'string') {\n    console.warn(`TaskManager.defineTask: 'taskName' argument must be a non-empty string.`);\n    return;\n  }\n  if (!taskExecutor || typeof taskExecutor !== 'function') {\n    console.warn(`TaskManager.defineTask: 'task' argument must be a function.`);\n    return;\n  }\n  tasks.set(taskName, taskExecutor);\n}\nexport function isTaskDefined(taskName) {\n  return tasks.has(taskName);\n}\nexport function isTaskRegisteredAsync(_x) {\n  return _isTaskRegisteredAsync.apply(this, arguments);\n}\nfunction _isTaskRegisteredAsync() {\n  _isTaskRegisteredAsync = _asyncToGenerator(function* (taskName) {\n    if (!ExpoTaskManager.isTaskRegisteredAsync) {\n      throw new UnavailabilityError('TaskManager', 'isTaskRegisteredAsync');\n    }\n    _validateTaskName(taskName);\n    return ExpoTaskManager.isTaskRegisteredAsync(taskName);\n  });\n  return _isTaskRegisteredAsync.apply(this, arguments);\n}\nexport function getTaskOptionsAsync(_x2) {\n  return _getTaskOptionsAsync.apply(this, arguments);\n}\nfunction _getTaskOptionsAsync() {\n  _getTaskOptionsAsync = _asyncToGenerator(function* (taskName) {\n    if (!ExpoTaskManager.getTaskOptionsAsync) {\n      throw new UnavailabilityError('TaskManager', 'getTaskOptionsAsync');\n    }\n    _validateTaskName(taskName);\n    return ExpoTaskManager.getTaskOptionsAsync(taskName);\n  });\n  return _getTaskOptionsAsync.apply(this, arguments);\n}\nexport function getRegisteredTasksAsync() {\n  return _getRegisteredTasksAsync.apply(this, arguments);\n}\nfunction _getRegisteredTasksAsync() {\n  _getRegisteredTasksAsync = _asyncToGenerator(function* () {\n    if (!ExpoTaskManager.getRegisteredTasksAsync) {\n      throw new UnavailabilityError('TaskManager', 'getRegisteredTasksAsync');\n    }\n    return ExpoTaskManager.getRegisteredTasksAsync();\n  });\n  return _getRegisteredTasksAsync.apply(this, arguments);\n}\nexport function unregisterTaskAsync(_x3) {\n  return _unregisterTaskAsync.apply(this, arguments);\n}\nfunction _unregisterTaskAsync() {\n  _unregisterTaskAsync = _asyncToGenerator(function* (taskName) {\n    if (!ExpoTaskManager.unregisterTaskAsync) {\n      throw new UnavailabilityError('TaskManager', 'unregisterTaskAsync');\n    }\n    _validateTaskName(taskName);\n    yield ExpoTaskManager.unregisterTaskAsync(taskName);\n  });\n  return _unregisterTaskAsync.apply(this, arguments);\n}\nexport function unregisterAllTasksAsync() {\n  return _unregisterAllTasksAsync.apply(this, arguments);\n}\nfunction _unregisterAllTasksAsync() {\n  _unregisterAllTasksAsync = _asyncToGenerator(function* () {\n    if (!ExpoTaskManager.unregisterAllTasksAsync) {\n      throw new UnavailabilityError('TaskManager', 'unregisterAllTasksAsync');\n    }\n    yield ExpoTaskManager.unregisterAllTasksAsync();\n  });\n  return _unregisterAllTasksAsync.apply(this, arguments);\n}\nif (ExpoTaskManager) {\n  var eventEmitter = new EventEmitter(ExpoTaskManager);\n  eventEmitter.addListener(ExpoTaskManager.EVENT_NAME, function () {\n    var _ref2 = _asyncToGenerator(function* (_ref) {\n      var data = _ref.data,\n        error = _ref.error,\n        executionInfo = _ref.executionInfo;\n      var eventId = executionInfo.eventId,\n        taskName = executionInfo.taskName;\n      var taskExecutor = tasks.get(taskName);\n      var result = null;\n      if (taskExecutor) {\n        try {\n          result = yield taskExecutor({\n            data: data,\n            error: error,\n            executionInfo: executionInfo\n          });\n        } catch (error) {\n          console.error(`TaskManager: Task \"${taskName}\" failed:`, error);\n        } finally {\n          yield ExpoTaskManager.notifyTaskFinishedAsync(taskName, {\n            eventId: eventId,\n            result: result\n          });\n        }\n      } else {\n        console.warn(`TaskManager: Task \"${taskName}\" has been executed but looks like it is not defined. Please make sure that \"TaskManager.defineTask\" is called during initialization phase.`);\n        yield ExpoTaskManager.notifyTaskFinishedAsync(taskName, {\n          eventId: eventId,\n          result: result\n        });\n        yield ExpoTaskManager.unregisterTaskAsync(taskName);\n      }\n    });\n    return function (_x4) {\n      return _ref2.apply(this, arguments);\n    };\n  }());\n}\nexport function isAvailableAsync() {\n  return _isAvailableAsync.apply(this, arguments);\n}\nfunction _isAvailableAsync() {\n  _isAvailableAsync = _asyncToGenerator(function* () {\n    return yield ExpoTaskManager.isAvailableAsync();\n  });\n  return _isAvailableAsync.apply(this, arguments);\n}","map":{"version":3,"names":["EventEmitter","UnavailabilityError","ExpoTaskManager","tasks","Map","_validateTaskName","taskName","TypeError","defineTask","taskExecutor","console","warn","set","isTaskDefined","has","isTaskRegisteredAsync","_x","_isTaskRegisteredAsync","apply","arguments","_asyncToGenerator","getTaskOptionsAsync","_x2","_getTaskOptionsAsync","getRegisteredTasksAsync","_getRegisteredTasksAsync","unregisterTaskAsync","_x3","_unregisterTaskAsync","unregisterAllTasksAsync","_unregisterAllTasksAsync","eventEmitter","addListener","EVENT_NAME","_ref2","_ref","data","error","executionInfo","eventId","get","result","notifyTaskFinishedAsync","_x4","isAvailableAsync","_isAvailableAsync"],"sources":["C:\\Users\\Ayamo\\Downloads\\driver-master\\node_modules\\expo-task-manager\\src\\TaskManager.ts"],"sourcesContent":["import { EventEmitter, UnavailabilityError } from 'expo-modules-core';\n\nimport ExpoTaskManager from './ExpoTaskManager';\n\n// @needsAudit @docsMissing\n/**\n * Error object that can be received through [`TaskManagerTaskBody`](#taskmanagertaskbody) when the\n * task fails.\n */\nexport interface TaskManagerError {\n  code: string | number;\n  message: string;\n}\n\n// @needsAudit\n/**\n * Represents the object that is passed to the task executor.\n */\nexport interface TaskManagerTaskBody<T = unknown> {\n  /**\n   * An object of data passed to the task executor. Its properties depends on the type of the task.\n   */\n  data: T;\n\n  /**\n   * Error object if the task failed or `null` otherwise.\n   */\n  error: TaskManagerError | null;\n\n  /**\n   * Additional details containing unique ID of task event and name of the task.\n   */\n  executionInfo: TaskManagerTaskBodyExecutionInfo;\n}\n\n// @needsAudit\n/**\n * Additional details about execution provided in `TaskManagerTaskBody`.\n */\nexport interface TaskManagerTaskBodyExecutionInfo {\n  /**\n   * State of the application.\n   * @platform ios\n   */\n  appState?: 'active' | 'background' | 'inactive';\n  /**\n   * Unique ID of task event.\n   */\n  eventId: string;\n  /**\n   * Name of the task.\n   */\n  taskName: string;\n}\n\n// @needsAudit\n/**\n * Represents an already registered task.\n */\nexport interface TaskManagerTask {\n  /**\n   * Name that the task is registered with.\n   */\n  taskName: string;\n\n  /**\n   * Type of the task which depends on how the task was registered.\n   */\n  taskType: string;\n\n  /**\n   * Provides `options` that the task was registered with.\n   */\n  options: any;\n}\n\n/**\n * @deprecated Use `TaskManagerTask` instead.\n * @hidden\n */\nexport interface RegisteredTask extends TaskManagerTask {}\n\n// @needsAudit\n/**\n * Type of task executor – a function that handles the task.\n */\nexport type TaskManagerTaskExecutor<T = unknown> = (body: TaskManagerTaskBody<T>) => void;\n\nconst tasks: Map<string, TaskManagerTaskExecutor<any>> = new Map<\n  string,\n  TaskManagerTaskExecutor<any>\n>();\n\nfunction _validateTaskName(taskName) {\n  if (!taskName || typeof taskName !== 'string') {\n    throw new TypeError('`taskName` must be a non-empty string.');\n  }\n}\n\n// @needsAudit\n/**\n * Defines task function. It must be called in the global scope of your JavaScript bundle.\n * In particular, it cannot be called in any of React lifecycle methods like `componentDidMount`.\n * This limitation is due to the fact that when the application is launched in the background,\n * we need to spin up your JavaScript app, run your task and then shut down — no views are mounted\n * in this scenario.\n *\n * @param taskName Name of the task. It must be the same as the name you provided when registering the task.\n * @param taskExecutor A function that will be invoked when the task with given `taskName` is executed.\n */\nexport function defineTask<T = unknown>(\n  taskName: string,\n  taskExecutor: TaskManagerTaskExecutor<T>\n) {\n  if (!taskName || typeof taskName !== 'string') {\n    console.warn(`TaskManager.defineTask: 'taskName' argument must be a non-empty string.`);\n    return;\n  }\n  if (!taskExecutor || typeof taskExecutor !== 'function') {\n    console.warn(`TaskManager.defineTask: 'task' argument must be a function.`);\n    return;\n  }\n  tasks.set(taskName, taskExecutor);\n}\n\n// @needsAudit\n/**\n * Checks whether the task is already defined.\n *\n * @param taskName Name of the task.\n */\nexport function isTaskDefined(taskName: string): boolean {\n  return tasks.has(taskName);\n}\n\n// @needsAudit\n/**\n * Determine whether the task is registered. Registered tasks are stored in a persistent storage and\n * preserved between sessions.\n *\n * @param taskName Name of the task.\n * @returns A promise which fulfills with a `boolean` value whether or not the task with given name\n * is already registered.\n */\nexport async function isTaskRegisteredAsync(taskName: string): Promise<boolean> {\n  if (!ExpoTaskManager.isTaskRegisteredAsync) {\n    throw new UnavailabilityError('TaskManager', 'isTaskRegisteredAsync');\n  }\n\n  _validateTaskName(taskName);\n  return ExpoTaskManager.isTaskRegisteredAsync(taskName);\n}\n\n// @needsAudit\n/**\n * Retrieves `options` associated with the task, that were passed to the function registering the task\n * (eg. `Location.startLocationUpdatesAsync`).\n *\n * @param taskName Name of the task.\n * @return A promise which fulfills with the `options` object that was passed while registering task\n * with given name or `null` if task couldn't be found.\n */\nexport async function getTaskOptionsAsync<TaskOptions>(taskName: string): Promise<TaskOptions> {\n  if (!ExpoTaskManager.getTaskOptionsAsync) {\n    throw new UnavailabilityError('TaskManager', 'getTaskOptionsAsync');\n  }\n\n  _validateTaskName(taskName);\n  return ExpoTaskManager.getTaskOptionsAsync(taskName);\n}\n\n// @needsAudit\n/**\n * Provides information about tasks registered in the app.\n *\n * @returns A promise which fulfills with an array of tasks registered in the app. Example:\n * ```json\n * [\n *   {\n *     taskName: 'location-updates-task-name',\n *     taskType: 'location',\n *     options: {\n *       accuracy: Location.Accuracy.High,\n *       showsBackgroundLocationIndicator: false,\n *     },\n *   },\n *   {\n *     taskName: 'geofencing-task-name',\n *     taskType: 'geofencing',\n *     options: {\n *       regions: [...],\n *     },\n *   },\n * ]\n * ```\n */\nexport async function getRegisteredTasksAsync(): Promise<TaskManagerTask[]> {\n  if (!ExpoTaskManager.getRegisteredTasksAsync) {\n    throw new UnavailabilityError('TaskManager', 'getRegisteredTasksAsync');\n  }\n\n  return ExpoTaskManager.getRegisteredTasksAsync();\n}\n\n// @needsAudit\n/**\n * Unregisters task from the app, so the app will not be receiving updates for that task anymore.\n * _It is recommended to use methods specialized by modules that registered the task, eg.\n * [`Location.stopLocationUpdatesAsync`](./location/#expolocationstoplocationupdatesasynctaskname)._\n *\n * @param taskName Name of the task to unregister.\n * @return A promise which fulfills as soon as the task is unregistered.\n */\nexport async function unregisterTaskAsync(taskName: string): Promise<void> {\n  if (!ExpoTaskManager.unregisterTaskAsync) {\n    throw new UnavailabilityError('TaskManager', 'unregisterTaskAsync');\n  }\n\n  _validateTaskName(taskName);\n  await ExpoTaskManager.unregisterTaskAsync(taskName);\n}\n\n// @needsAudit\n/**\n * Unregisters all tasks registered for the running app. You may want to call this when the user is\n * signing out and you no longer need to track his location or run any other background tasks.\n * @return A promise which fulfills as soon as all tasks are completely unregistered.\n */\nexport async function unregisterAllTasksAsync(): Promise<void> {\n  if (!ExpoTaskManager.unregisterAllTasksAsync) {\n    throw new UnavailabilityError('TaskManager', 'unregisterAllTasksAsync');\n  }\n\n  await ExpoTaskManager.unregisterAllTasksAsync();\n}\n\nif (ExpoTaskManager) {\n  const eventEmitter = new EventEmitter(ExpoTaskManager);\n  eventEmitter.addListener<TaskManagerTaskBody>(\n    ExpoTaskManager.EVENT_NAME,\n    async ({ data, error, executionInfo }) => {\n      const { eventId, taskName } = executionInfo;\n      const taskExecutor = tasks.get(taskName);\n      let result: any = null;\n\n      if (taskExecutor) {\n        try {\n          // Execute JS task\n          result = await taskExecutor({ data, error, executionInfo });\n        } catch (error) {\n          console.error(`TaskManager: Task \"${taskName}\" failed:`, error);\n        } finally {\n          // Notify manager the task is finished.\n          await ExpoTaskManager.notifyTaskFinishedAsync(taskName, { eventId, result });\n        }\n      } else {\n        console.warn(\n          `TaskManager: Task \"${taskName}\" has been executed but looks like it is not defined. Please make sure that \"TaskManager.defineTask\" is called during initialization phase.`\n        );\n        // No tasks defined -> we need to notify about finish anyway.\n        await ExpoTaskManager.notifyTaskFinishedAsync(taskName, { eventId, result });\n        // We should also unregister such tasks automatically as the task might have been removed\n        // from the app or just renamed - in that case it needs to be registered again (with the new name).\n        await ExpoTaskManager.unregisterTaskAsync(taskName);\n      }\n    }\n  );\n}\n\n// @needsAudit\n/**\n * Determine if the `TaskManager` API can be used in this app.\n * @return A promise fulfills with `true` if the API can be used, and `false` otherwise.\n * On the web it always returns `false`.\n */\nexport async function isAvailableAsync(): Promise<boolean> {\n  return await ExpoTaskManager.isAvailableAsync();\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}