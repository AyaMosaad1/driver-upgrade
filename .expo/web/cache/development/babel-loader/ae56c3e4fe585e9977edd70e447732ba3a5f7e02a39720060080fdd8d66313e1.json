{"ast":null,"code":"import _regeneratorRuntime from \"@babel/runtime/regenerator\";\nimport { EventEmitter, UnavailabilityError } from 'expo-modules-core';\nimport ExpoTaskManager from \"./ExpoTaskManager\";\nvar tasks = new Map();\nfunction _validateTaskName(taskName) {\n  if (!taskName || typeof taskName !== 'string') {\n    throw new TypeError('`taskName` must be a non-empty string.');\n  }\n}\nexport function defineTask(taskName, taskExecutor) {\n  if (!taskName || typeof taskName !== 'string') {\n    console.warn(\"TaskManager.defineTask: 'taskName' argument must be a non-empty string.\");\n    return;\n  }\n  if (!taskExecutor || typeof taskExecutor !== 'function') {\n    console.warn(\"TaskManager.defineTask: 'task' argument must be a function.\");\n    return;\n  }\n  tasks.set(taskName, taskExecutor);\n}\nexport function isTaskDefined(taskName) {\n  return tasks.has(taskName);\n}\nexport function isTaskRegisteredAsync(taskName) {\n  return _regeneratorRuntime.async(function isTaskRegisteredAsync$(_context) {\n    while (1) {\n      switch (_context.prev = _context.next) {\n        case 0:\n          if (ExpoTaskManager.isTaskRegisteredAsync) {\n            _context.next = 2;\n            break;\n          }\n          throw new UnavailabilityError('TaskManager', 'isTaskRegisteredAsync');\n        case 2:\n          _validateTaskName(taskName);\n          return _context.abrupt(\"return\", ExpoTaskManager.isTaskRegisteredAsync(taskName));\n        case 4:\n        case \"end\":\n          return _context.stop();\n      }\n    }\n  }, null, null, null, Promise);\n}\nexport function getTaskOptionsAsync(taskName) {\n  return _regeneratorRuntime.async(function getTaskOptionsAsync$(_context2) {\n    while (1) {\n      switch (_context2.prev = _context2.next) {\n        case 0:\n          if (ExpoTaskManager.getTaskOptionsAsync) {\n            _context2.next = 2;\n            break;\n          }\n          throw new UnavailabilityError('TaskManager', 'getTaskOptionsAsync');\n        case 2:\n          _validateTaskName(taskName);\n          return _context2.abrupt(\"return\", ExpoTaskManager.getTaskOptionsAsync(taskName));\n        case 4:\n        case \"end\":\n          return _context2.stop();\n      }\n    }\n  }, null, null, null, Promise);\n}\nexport function getRegisteredTasksAsync() {\n  return _regeneratorRuntime.async(function getRegisteredTasksAsync$(_context3) {\n    while (1) {\n      switch (_context3.prev = _context3.next) {\n        case 0:\n          if (ExpoTaskManager.getRegisteredTasksAsync) {\n            _context3.next = 2;\n            break;\n          }\n          throw new UnavailabilityError('TaskManager', 'getRegisteredTasksAsync');\n        case 2:\n          return _context3.abrupt(\"return\", ExpoTaskManager.getRegisteredTasksAsync());\n        case 3:\n        case \"end\":\n          return _context3.stop();\n      }\n    }\n  }, null, null, null, Promise);\n}\nexport function unregisterTaskAsync(taskName) {\n  return _regeneratorRuntime.async(function unregisterTaskAsync$(_context4) {\n    while (1) {\n      switch (_context4.prev = _context4.next) {\n        case 0:\n          if (ExpoTaskManager.unregisterTaskAsync) {\n            _context4.next = 2;\n            break;\n          }\n          throw new UnavailabilityError('TaskManager', 'unregisterTaskAsync');\n        case 2:\n          _validateTaskName(taskName);\n          _context4.next = 5;\n          return _regeneratorRuntime.awrap(ExpoTaskManager.unregisterTaskAsync(taskName));\n        case 5:\n        case \"end\":\n          return _context4.stop();\n      }\n    }\n  }, null, null, null, Promise);\n}\nexport function unregisterAllTasksAsync() {\n  return _regeneratorRuntime.async(function unregisterAllTasksAsync$(_context5) {\n    while (1) {\n      switch (_context5.prev = _context5.next) {\n        case 0:\n          if (ExpoTaskManager.unregisterAllTasksAsync) {\n            _context5.next = 2;\n            break;\n          }\n          throw new UnavailabilityError('TaskManager', 'unregisterAllTasksAsync');\n        case 2:\n          _context5.next = 4;\n          return _regeneratorRuntime.awrap(ExpoTaskManager.unregisterAllTasksAsync());\n        case 4:\n        case \"end\":\n          return _context5.stop();\n      }\n    }\n  }, null, null, null, Promise);\n}\nif (ExpoTaskManager) {\n  var eventEmitter = new EventEmitter(ExpoTaskManager);\n  eventEmitter.addListener(ExpoTaskManager.EVENT_NAME, function _callee(_ref) {\n    var data, error, executionInfo, eventId, taskName, taskExecutor, result;\n    return _regeneratorRuntime.async(function _callee$(_context6) {\n      while (1) {\n        switch (_context6.prev = _context6.next) {\n          case 0:\n            data = _ref.data, error = _ref.error, executionInfo = _ref.executionInfo;\n            eventId = executionInfo.eventId, taskName = executionInfo.taskName;\n            taskExecutor = tasks.get(taskName);\n            result = null;\n            if (!taskExecutor) {\n              _context6.next = 20;\n              break;\n            }\n            _context6.prev = 5;\n            _context6.next = 8;\n            return _regeneratorRuntime.awrap(taskExecutor({\n              data: data,\n              error: error,\n              executionInfo: executionInfo\n            }));\n          case 8:\n            result = _context6.sent;\n            _context6.next = 14;\n            break;\n          case 11:\n            _context6.prev = 11;\n            _context6.t0 = _context6[\"catch\"](5);\n            console.error(\"TaskManager: Task \\\"\" + taskName + \"\\\" failed:\", _context6.t0);\n          case 14:\n            _context6.prev = 14;\n            _context6.next = 17;\n            return _regeneratorRuntime.awrap(ExpoTaskManager.notifyTaskFinishedAsync(taskName, {\n              eventId: eventId,\n              result: result\n            }));\n          case 17:\n            return _context6.finish(14);\n          case 18:\n            _context6.next = 25;\n            break;\n          case 20:\n            console.warn(\"TaskManager: Task \\\"\" + taskName + \"\\\" has been executed but looks like it is not defined. Please make sure that \\\"TaskManager.defineTask\\\" is called during initialization phase.\");\n            _context6.next = 23;\n            return _regeneratorRuntime.awrap(ExpoTaskManager.notifyTaskFinishedAsync(taskName, {\n              eventId: eventId,\n              result: result\n            }));\n          case 23:\n            _context6.next = 25;\n            return _regeneratorRuntime.awrap(ExpoTaskManager.unregisterTaskAsync(taskName));\n          case 25:\n          case \"end\":\n            return _context6.stop();\n        }\n      }\n    }, null, null, [[5, 11, 14, 18]], Promise);\n  });\n}\nexport function isAvailableAsync() {\n  return _regeneratorRuntime.async(function isAvailableAsync$(_context7) {\n    while (1) {\n      switch (_context7.prev = _context7.next) {\n        case 0:\n          _context7.next = 2;\n          return _regeneratorRuntime.awrap(ExpoTaskManager.isAvailableAsync());\n        case 2:\n          return _context7.abrupt(\"return\", _context7.sent);\n        case 3:\n        case \"end\":\n          return _context7.stop();\n      }\n    }\n  }, null, null, null, Promise);\n}","map":{"version":3,"names":["EventEmitter","UnavailabilityError","ExpoTaskManager","tasks","Map","_validateTaskName","taskName","TypeError","defineTask","taskExecutor","console","warn","set","isTaskDefined","has","isTaskRegisteredAsync","_regeneratorRuntime","async","isTaskRegisteredAsync$","_context","prev","next","abrupt","stop","Promise","getTaskOptionsAsync","getTaskOptionsAsync$","_context2","getRegisteredTasksAsync","getRegisteredTasksAsync$","_context3","unregisterTaskAsync","unregisterTaskAsync$","_context4","awrap","unregisterAllTasksAsync","unregisterAllTasksAsync$","_context5","eventEmitter","addListener","EVENT_NAME","_callee","_ref","data","error","executionInfo","eventId","result","_callee$","_context6","get","sent","t0","notifyTaskFinishedAsync","finish","isAvailableAsync","isAvailableAsync$","_context7"],"sources":["C:\\Users\\Ayamo\\Downloads\\driver-master\\node_modules\\expo-task-manager\\src\\TaskManager.ts"],"sourcesContent":["import { EventEmitter, UnavailabilityError } from 'expo-modules-core';\n\nimport ExpoTaskManager from './ExpoTaskManager';\n\n// @needsAudit @docsMissing\n/**\n * Error object that can be received through [`TaskManagerTaskBody`](#taskmanagertaskbody) when the\n * task fails.\n */\nexport interface TaskManagerError {\n  code: string | number;\n  message: string;\n}\n\n// @needsAudit\n/**\n * Represents the object that is passed to the task executor.\n */\nexport interface TaskManagerTaskBody<T = object> {\n  /**\n   * An object of data passed to the task executor. Its properties depends on the type of the task.\n   */\n  data: T;\n\n  /**\n   * Error object if the task failed or `null` otherwise.\n   */\n  error: TaskManagerError | null;\n\n  /**\n   * Additional details containing unique ID of task event and name of the task.\n   */\n  executionInfo: TaskManagerTaskBodyExecutionInfo;\n}\n\n// @needsAudit\n/**\n * Additional details about execution provided in `TaskManagerTaskBody`.\n */\nexport interface TaskManagerTaskBodyExecutionInfo {\n  /**\n   * __(iOS only)__ State of the application.\n   */\n  appState?: 'active' | 'background' | 'inactive';\n  /**\n   * Unique ID of task event.\n   */\n  eventId: string;\n  /**\n   * Name of the task.\n   */\n  taskName: string;\n}\n\n// @needsAudit\n/**\n * Represents an already registered task.\n */\nexport interface TaskManagerTask {\n  /**\n   * Name that the task is registered with.\n   */\n  taskName: string;\n\n  /**\n   * Type of the task which depends on how the task was registered.\n   */\n  taskType: string;\n\n  /**\n   * Provides `options` that the task was registered with.\n   */\n  options: any;\n}\n\n/**\n * @deprecated Use `TaskManagerTask` instead.\n * @hidden\n */\nexport interface RegisteredTask extends TaskManagerTask {}\n\n// @needsAudit\n/**\n * Type of task executor – a function that handles the task.\n */\nexport type TaskManagerTaskExecutor = (body: TaskManagerTaskBody) => void;\n\nconst tasks: Map<string, TaskManagerTaskExecutor> = new Map<string, TaskManagerTaskExecutor>();\n\nfunction _validateTaskName(taskName) {\n  if (!taskName || typeof taskName !== 'string') {\n    throw new TypeError('`taskName` must be a non-empty string.');\n  }\n}\n\n// @needsAudit\n/**\n * Defines task function. It must be called in the global scope of your JavaScript bundle.\n * In particular, it cannot be called in any of React lifecycle methods like `componentDidMount`.\n * This limitation is due to the fact that when the application is launched in the background,\n * we need to spin up your JavaScript app, run your task and then shut down — no views are mounted\n * in this scenario.\n *\n * @param taskName Name of the task. It must be the same as the name you provided when registering the task.\n * @param taskExecutor A function that will be invoked when the task with given `taskName` is executed.\n */\nexport function defineTask(taskName: string, taskExecutor: TaskManagerTaskExecutor) {\n  if (!taskName || typeof taskName !== 'string') {\n    console.warn(`TaskManager.defineTask: 'taskName' argument must be a non-empty string.`);\n    return;\n  }\n  if (!taskExecutor || typeof taskExecutor !== 'function') {\n    console.warn(`TaskManager.defineTask: 'task' argument must be a function.`);\n    return;\n  }\n  tasks.set(taskName, taskExecutor);\n}\n\n// @needsAudit\n/**\n * Checks whether the task is already defined.\n *\n * @param taskName Name of the task.\n */\nexport function isTaskDefined(taskName: string): boolean {\n  return tasks.has(taskName);\n}\n\n// @needsAudit\n/**\n * Determine whether the task is registered. Registered tasks are stored in a persistent storage and\n * preserved between sessions.\n *\n * @param taskName Name of the task.\n * @returns A promise which fulfills with a `boolean` value whether or not the task with given name\n * is already registered.\n */\nexport async function isTaskRegisteredAsync(taskName: string): Promise<boolean> {\n  if (!ExpoTaskManager.isTaskRegisteredAsync) {\n    throw new UnavailabilityError('TaskManager', 'isTaskRegisteredAsync');\n  }\n\n  _validateTaskName(taskName);\n  return ExpoTaskManager.isTaskRegisteredAsync(taskName);\n}\n\n// @needsAudit\n/**\n * Retrieves `options` associated with the task, that were passed to the function registering the task\n * (eg. `Location.startLocationUpdatesAsync`).\n *\n * @param taskName Name of the task.\n * @return A promise which fulfills with the `options` object that was passed while registering task\n * with given name or `null` if task couldn't be found.\n */\nexport async function getTaskOptionsAsync<TaskOptions>(taskName: string): Promise<TaskOptions> {\n  if (!ExpoTaskManager.getTaskOptionsAsync) {\n    throw new UnavailabilityError('TaskManager', 'getTaskOptionsAsync');\n  }\n\n  _validateTaskName(taskName);\n  return ExpoTaskManager.getTaskOptionsAsync(taskName);\n}\n\n// @needsAudit\n/**\n * Provides information about tasks registered in the app.\n *\n * @returns A promise which fulfills with an array of tasks registered in the app. Example:\n * ```json\n * [\n *   {\n *     taskName: 'location-updates-task-name',\n *     taskType: 'location',\n *     options: {\n *       accuracy: Location.Accuracy.High,\n *       showsBackgroundLocationIndicator: false,\n *     },\n *   },\n *   {\n *     taskName: 'geofencing-task-name',\n *     taskType: 'geofencing',\n *     options: {\n *       regions: [...],\n *     },\n *   },\n * ]\n * ```\n */\nexport async function getRegisteredTasksAsync(): Promise<TaskManagerTask[]> {\n  if (!ExpoTaskManager.getRegisteredTasksAsync) {\n    throw new UnavailabilityError('TaskManager', 'getRegisteredTasksAsync');\n  }\n\n  return ExpoTaskManager.getRegisteredTasksAsync();\n}\n\n// @needsAudit\n/**\n * Unregisters task from the app, so the app will not be receiving updates for that task anymore.\n * _It is recommended to use methods specialized by modules that registered the task, eg.\n * [`Location.stopLocationUpdatesAsync`](./location/#expolocationstoplocationupdatesasynctaskname)._\n *\n * @param taskName Name of the task to unregister.\n * @return A promise which fulfills as soon as the task is unregistered.\n */\nexport async function unregisterTaskAsync(taskName: string): Promise<void> {\n  if (!ExpoTaskManager.unregisterTaskAsync) {\n    throw new UnavailabilityError('TaskManager', 'unregisterTaskAsync');\n  }\n\n  _validateTaskName(taskName);\n  await ExpoTaskManager.unregisterTaskAsync(taskName);\n}\n\n// @needsAudit\n/**\n * Unregisters all tasks registered for the running app. You may want to call this when the user is\n * signing out and you no longer need to track his location or run any other background tasks.\n * @return A promise which fulfills as soon as all tasks are completely unregistered.\n */\nexport async function unregisterAllTasksAsync(): Promise<void> {\n  if (!ExpoTaskManager.unregisterAllTasksAsync) {\n    throw new UnavailabilityError('TaskManager', 'unregisterAllTasksAsync');\n  }\n\n  await ExpoTaskManager.unregisterAllTasksAsync();\n}\n\nif (ExpoTaskManager) {\n  const eventEmitter = new EventEmitter(ExpoTaskManager);\n  eventEmitter.addListener<TaskManagerTaskBody>(\n    ExpoTaskManager.EVENT_NAME,\n    async ({ data, error, executionInfo }) => {\n      const { eventId, taskName } = executionInfo;\n      const taskExecutor = tasks.get(taskName);\n      let result: any = null;\n\n      if (taskExecutor) {\n        try {\n          // Execute JS task\n          result = await taskExecutor({ data, error, executionInfo });\n        } catch (error) {\n          console.error(`TaskManager: Task \"${taskName}\" failed:`, error);\n        } finally {\n          // Notify manager the task is finished.\n          await ExpoTaskManager.notifyTaskFinishedAsync(taskName, { eventId, result });\n        }\n      } else {\n        console.warn(\n          `TaskManager: Task \"${taskName}\" has been executed but looks like it is not defined. Please make sure that \"TaskManager.defineTask\" is called during initialization phase.`\n        );\n        // No tasks defined -> we need to notify about finish anyway.\n        await ExpoTaskManager.notifyTaskFinishedAsync(taskName, { eventId, result });\n        // We should also unregister such tasks automatically as the task might have been removed\n        // from the app or just renamed - in that case it needs to be registered again (with the new name).\n        await ExpoTaskManager.unregisterTaskAsync(taskName);\n      }\n    }\n  );\n}\n\n// @needsAudit\n/**\n * Determine if the `TaskManager` API can be used in this app.\n * @return A promise fulfills with `true` if the API can be used, and `false` otherwise.\n * On the web it always returns `false`.\n */\nexport async function isAvailableAsync(): Promise<boolean> {\n  return await ExpoTaskManager.isAvailableAsync();\n}\n"],"mappings":";AAAA,SAASA,YAAY,EAAEC,mBAAmB,QAAQ,mBAAmB;AAErE,OAAOC,eAAe;AAqFtB,IAAMC,KAAK,GAAyC,IAAIC,GAAG,EAAmC;AAE9F,SAASC,iBAAiBA,CAACC,QAAQ;EACjC,IAAI,CAACA,QAAQ,IAAI,OAAOA,QAAQ,KAAK,QAAQ,EAAE;IAC7C,MAAM,IAAIC,SAAS,CAAC,wCAAwC,CAAC;;AAEjE;AAaA,OAAM,SAAUC,UAAUA,CAACF,QAAgB,EAAEG,YAAqC;EAChF,IAAI,CAACH,QAAQ,IAAI,OAAOA,QAAQ,KAAK,QAAQ,EAAE;IAC7CI,OAAO,CAACC,IAAI,0EAA0E,CAAC;IACvF;;EAEF,IAAI,CAACF,YAAY,IAAI,OAAOA,YAAY,KAAK,UAAU,EAAE;IACvDC,OAAO,CAACC,IAAI,8DAA8D,CAAC;IAC3E;;EAEFR,KAAK,CAACS,GAAG,CAACN,QAAQ,EAAEG,YAAY,CAAC;AACnC;AAQA,OAAM,SAAUI,aAAaA,CAACP,QAAgB;EAC5C,OAAOH,KAAK,CAACW,GAAG,CAACR,QAAQ,CAAC;AAC5B;AAWA,OAAO,SAAeS,qBAAqBA,CAACT,QAAgB;EAAA,OAAAU,mBAAA,CAAAC,KAAA,UAAAC,uBAAAC,QAAA;IAAA;MAAA,QAAAA,QAAA,CAAAC,IAAA,GAAAD,QAAA,CAAAE,IAAA;QAAA;UAAA,IACrDnB,eAAe,CAACa,qBAAqB;YAAAI,QAAA,CAAAE,IAAA;YAAA;UAAA;UAAA,MAClC,IAAIpB,mBAAmB,CAAC,aAAa,EAAE,uBAAuB,CAAC;QAAA;UAGvEI,iBAAiB,CAACC,QAAQ,CAAC;UAAC,OAAAa,QAAA,CAAAG,MAAA,WACrBpB,eAAe,CAACa,qBAAqB,CAACT,QAAQ,CAAC;QAAA;QAAA;UAAA,OAAAa,QAAA,CAAAI,IAAA;MAAA;IAAA;EAAA,qBAAAC,OAAA;AAAA;AAYxD,OAAO,SAAeC,mBAAmBA,CAAcnB,QAAgB;EAAA,OAAAU,mBAAA,CAAAC,KAAA,UAAAS,qBAAAC,SAAA;IAAA;MAAA,QAAAA,SAAA,CAAAP,IAAA,GAAAO,SAAA,CAAAN,IAAA;QAAA;UAAA,IAChEnB,eAAe,CAACuB,mBAAmB;YAAAE,SAAA,CAAAN,IAAA;YAAA;UAAA;UAAA,MAChC,IAAIpB,mBAAmB,CAAC,aAAa,EAAE,qBAAqB,CAAC;QAAA;UAGrEI,iBAAiB,CAACC,QAAQ,CAAC;UAAC,OAAAqB,SAAA,CAAAL,MAAA,WACrBpB,eAAe,CAACuB,mBAAmB,CAACnB,QAAQ,CAAC;QAAA;QAAA;UAAA,OAAAqB,SAAA,CAAAJ,IAAA;MAAA;IAAA;EAAA,qBAAAC,OAAA;AAAA;AA4BtD,OAAO,SAAeI,uBAAuBA,CAAA;EAAA,OAAAZ,mBAAA,CAAAC,KAAA,UAAAY,yBAAAC,SAAA;IAAA;MAAA,QAAAA,SAAA,CAAAV,IAAA,GAAAU,SAAA,CAAAT,IAAA;QAAA;UAAA,IACtCnB,eAAe,CAAC0B,uBAAuB;YAAAE,SAAA,CAAAT,IAAA;YAAA;UAAA;UAAA,MACpC,IAAIpB,mBAAmB,CAAC,aAAa,EAAE,yBAAyB,CAAC;QAAA;UAAA,OAAA6B,SAAA,CAAAR,MAAA,WAGlEpB,eAAe,CAAC0B,uBAAuB,EAAE;QAAA;QAAA;UAAA,OAAAE,SAAA,CAAAP,IAAA;MAAA;IAAA;EAAA,qBAAAC,OAAA;AAAA;AAYlD,OAAO,SAAeO,mBAAmBA,CAACzB,QAAgB;EAAA,OAAAU,mBAAA,CAAAC,KAAA,UAAAe,qBAAAC,SAAA;IAAA;MAAA,QAAAA,SAAA,CAAAb,IAAA,GAAAa,SAAA,CAAAZ,IAAA;QAAA;UAAA,IACnDnB,eAAe,CAAC6B,mBAAmB;YAAAE,SAAA,CAAAZ,IAAA;YAAA;UAAA;UAAA,MAChC,IAAIpB,mBAAmB,CAAC,aAAa,EAAE,qBAAqB,CAAC;QAAA;UAGrEI,iBAAiB,CAACC,QAAQ,CAAC;UAAC2B,SAAA,CAAAZ,IAAA;UAAA,OAAAL,mBAAA,CAAAkB,KAAA,CACtBhC,eAAe,CAAC6B,mBAAmB,CAACzB,QAAQ,CAAC;QAAA;QAAA;UAAA,OAAA2B,SAAA,CAAAV,IAAA;MAAA;IAAA;EAAA,qBAAAC,OAAA;AAAA;AASrD,OAAO,SAAeW,uBAAuBA,CAAA;EAAA,OAAAnB,mBAAA,CAAAC,KAAA,UAAAmB,yBAAAC,SAAA;IAAA;MAAA,QAAAA,SAAA,CAAAjB,IAAA,GAAAiB,SAAA,CAAAhB,IAAA;QAAA;UAAA,IACtCnB,eAAe,CAACiC,uBAAuB;YAAAE,SAAA,CAAAhB,IAAA;YAAA;UAAA;UAAA,MACpC,IAAIpB,mBAAmB,CAAC,aAAa,EAAE,yBAAyB,CAAC;QAAA;UAAAoC,SAAA,CAAAhB,IAAA;UAAA,OAAAL,mBAAA,CAAAkB,KAAA,CAGnEhC,eAAe,CAACiC,uBAAuB,EAAE;QAAA;QAAA;UAAA,OAAAE,SAAA,CAAAd,IAAA;MAAA;IAAA;EAAA,qBAAAC,OAAA;AAAA;AAGjD,IAAItB,eAAe,EAAE;EACnB,IAAMoC,YAAY,GAAG,IAAItC,YAAY,CAACE,eAAe,CAAC;EACtDoC,YAAY,CAACC,WAAW,CACtBrC,eAAe,CAACsC,UAAU,EAC1B,SAAAC,QAAAC,IAAA;IAAA,IAAAC,IAAA,EAAAC,KAAA,EAAAC,aAAA,EAAAC,OAAA,EAAAxC,QAAA,EAAAG,YAAA,EAAAsC,MAAA;IAAA,OAAA/B,mBAAA,CAAAC,KAAA,UAAA+B,SAAAC,SAAA;MAAA;QAAA,QAAAA,SAAA,CAAA7B,IAAA,GAAA6B,SAAA,CAAA5B,IAAA;UAAA;YAASsB,IAAI,GAAAD,IAAA,CAAJC,IAAI,EAAEC,KAAK,GAAAF,IAAA,CAALE,KAAK,EAAEC,aAAa,GAAAH,IAAA,CAAbG,aAAa;YACzBC,OAAO,GAAeD,aAAa,CAAnCC,OAAO,EAAExC,QAAQ,GAAKuC,aAAa,CAA1BvC,QAAQ;YACnBG,YAAY,GAAGN,KAAK,CAAC+C,GAAG,CAAC5C,QAAQ,CAAC;YACpCyC,MAAM,GAAQ,IAAI;YAAA,KAElBtC,YAAY;cAAAwC,SAAA,CAAA5B,IAAA;cAAA;YAAA;YAAA4B,SAAA,CAAA7B,IAAA;YAAA6B,SAAA,CAAA5B,IAAA;YAAA,OAAAL,mBAAA,CAAAkB,KAAA,CAGGzB,YAAY,CAAC;cAAEkC,IAAI,EAAJA,IAAI;cAAEC,KAAK,EAALA,KAAK;cAAEC,aAAa,EAAbA;YAAa,CAAE,CAAC;UAAA;YAA3DE,MAAM,GAAAE,SAAA,CAAAE,IAAA;YAAAF,SAAA,CAAA5B,IAAA;YAAA;UAAA;YAAA4B,SAAA,CAAA7B,IAAA;YAAA6B,SAAA,CAAAG,EAAA,GAAAH,SAAA;YAENvC,OAAO,CAACkC,KAAK,0BAAuBtC,QAAQ,iBAAA2C,SAAA,CAAAG,EAAkB,CAAC;UAAC;YAAAH,SAAA,CAAA7B,IAAA;YAAA6B,SAAA,CAAA5B,IAAA;YAAA,OAAAL,mBAAA,CAAAkB,KAAA,CAG1DhC,eAAe,CAACmD,uBAAuB,CAAC/C,QAAQ,EAAE;cAAEwC,OAAO,EAAPA,OAAO;cAAEC,MAAM,EAANA;YAAM,CAAE,CAAC;UAAA;YAAA,OAAAE,SAAA,CAAAK,MAAA;UAAA;YAAAL,SAAA,CAAA5B,IAAA;YAAA;UAAA;YAG9EX,OAAO,CAACC,IAAI,0BACYL,QAAQ,mJAA6I,CAC5K;YAAC2C,SAAA,CAAA5B,IAAA;YAAA,OAAAL,mBAAA,CAAAkB,KAAA,CAEIhC,eAAe,CAACmD,uBAAuB,CAAC/C,QAAQ,EAAE;cAAEwC,OAAO,EAAPA,OAAO;cAAEC,MAAM,EAANA;YAAM,CAAE,CAAC;UAAA;YAAAE,SAAA,CAAA5B,IAAA;YAAA,OAAAL,mBAAA,CAAAkB,KAAA,CAGtEhC,eAAe,CAAC6B,mBAAmB,CAACzB,QAAQ,CAAC;UAAA;UAAA;YAAA,OAAA2C,SAAA,CAAA1B,IAAA;QAAA;MAAA;IAAA,kCAAAC,OAAA;EAAA,CAEtD,CACF;;AASH,OAAO,SAAe+B,gBAAgBA,CAAA;EAAA,OAAAvC,mBAAA,CAAAC,KAAA,UAAAuC,kBAAAC,SAAA;IAAA;MAAA,QAAAA,SAAA,CAAArC,IAAA,GAAAqC,SAAA,CAAApC,IAAA;QAAA;UAAAoC,SAAA,CAAApC,IAAA;UAAA,OAAAL,mBAAA,CAAAkB,KAAA,CACvBhC,eAAe,CAACqD,gBAAgB,EAAE;QAAA;UAAA,OAAAE,SAAA,CAAAnC,MAAA,WAAAmC,SAAA,CAAAN,IAAA;QAAA;QAAA;UAAA,OAAAM,SAAA,CAAAlC,IAAA;MAAA;IAAA;EAAA,qBAAAC,OAAA;AAAA"},"metadata":{},"sourceType":"module","externalDependencies":[]}